/**
 * 
 */
package fanShe;

/**
 * @author ChristinaXinny
 * @date 2020_10_24 17:28:04
 */


/*
 * 凡是被【重点】括起来的 是要会写代码的
 * 1. 反射机制概述
 * 2. 理解class类 并【获取class实例】
 * 3. 类的加载与ClassLoader的理解
 * 4. 【创建运行时类的对象】
 * 5. 获取运行时类的完整结构
 * 6. 【调用运行时类的指定结构】
 * 7. 反射应用： 动态代理 
 * 
 * 
 * 
 * 
 * 
 * 疑问1:通过直接new的方式或反射的方式都可以调用公共的结构,开发中到底用那个?
 * 建议:直接new的方式。
 * 什么时候会使用:反射的方式反射的特征:动态性
 * 疑问2:反射机制与面向对象中的封装性是不是矛盾的?如何看待两个技术?
 * 不矛盾。
 * 
 * 
 * 
 * 关于java.lang.cLass 类的理解
 * 
 * 1.类的加载过程:
 * 程序经过javac .exe命令以后,会生成一个或多个字节码文件(class.结尾)
 * 接着我们使用java.exe命令对某个字节码文件进行解释运行。
 * 相当于将某个字节码文件加载到内存中。此过程就称为类的加载。
 * 加载到内存中的类,我们就称为运行时类,
 * 此运行时类,就作为Class 的一个实例。
 * 2.换句话说,class 的实例就对应着一个运行时类。
 * 3.加载到内存中的运行时类，会缓存一定时间 在此时间内 我们可以通过不同的方式
 * 		来获取此运行时类
 * 
 * 
 * 
 * /*
 * 
 * 见 test3
 * 法1.调用运行时类的属性：class
 * 法2.通过运行时类的对象 调用getClass（）
 * 法3.调用Class静态方法：forName（String classPath）类的路径
 * 法4.使用类的加载器：ClassLoader
		以上4中 前三种要掌握 第四种作为了解
		其中第三种为实际开发中所常用 
		第1种在编译的时候如果不对就会报错 不是特别好
		第二种 直接用new出来的对象 那就何必在回来调用一次？所以不是特别好
		第三种 如果路径不对会抛出异常 这个可以在捕获异常的时候进行处理 
		就是说 不会在编译的时候出现的错 比较好 在运行之后才反映 
		这样会更加好体现出 动态性
		动态性： 在编译的时候不会体现
		
		*/
/*
 * 
 * 
 * 
 */


/*
 * 
 * 加上泛型 就可以避免在后面进行强类型转换
 * 不加泛型的话取出来是object类型的，需要强制类型转换，
 * 而加了泛型，取出来之后直接就是泛型声明的类型
1，类型安全。 泛型的主要目标是提高 Java 程序的类型安全。
通过知道使用泛型定义的变量的类型限制，编译器可以在一个高得多的程度上
验证类型假设。没有泛型，这些假设就只存在于程序员的头脑中
（或者如果幸运的话，还存在于代码注释中）。

2，消除强制类型转换。 泛型的一个附带好处是，消除源代码中的许多强制
类型转换。这使得代码更加可读，并且减少了出错机会。

3，潜在的性能收益。 泛型为较大的优化带来可能。在泛型的初始实现中，
编译器将强制类型转换（没有泛型的话，程序员会指定这些强制类型转换）
插入生成的字节码中。但是更多类型信息可用于编译器这一事实，
为未来版本的 JVM 的优化带来可能。由于泛型的实现方式，支持泛型
（几乎）不需要 JVM 或类文件更改。所有工作都在编译器中完成，
编译器生成类似于没有泛型（和强制类型转换）时所写的代码，
只是更能确保类型安全而已
*/


public class AASummary {

}
